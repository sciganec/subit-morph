<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>SUBIT 3D Attractor Explorer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: #0a0e27;
            color: #e0e0e0;
            overflow: hidden;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
        
        .app-container {
            display: grid;
            grid-template-columns: 320px 1fr 350px;
            height: 100vh;
            gap: 0;
        }
        
        /* LEFT PANEL */
        .left-panel {
            background: linear-gradient(180deg, #1a1f3a 0%, #0f1228 100%);
            padding: 25px;
            overflow-y: auto;
            border-right: 1px solid #2a3f5f;
        }
        
        .logo {
            text-align: center;
            margin-bottom: 25px;
            padding-bottom: 20px;
            border-bottom: 2px solid #2a3f5f;
        }
        
        .logo h1 {
            font-size: 1.5rem;
            background: linear-gradient(135deg, #4fc3f7, #9c27b0);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 5px;
        }
        
        .logo p {
            font-size: 0.75rem;
            color: #90a4ae;
        }
        
        .input-section {
            margin-bottom: 25px;
        }
        
        .input-section label {
            display: block;
            color: #4fc3f7;
            font-size: 0.9rem;
            margin-bottom: 8px;
            font-weight: 600;
        }
        
        textarea {
            width: 100%;
            min-height: 100px;
            background: #0a0e27;
            color: #e0e0e0;
            border: 1px solid #4fc3f7;
            border-radius: 6px;
            padding: 10px;
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
            resize: vertical;
            -webkit-user-select: text;
            user-select: text;
        }
        
        textarea:focus {
            outline: none;
            border-color: #9c27b0;
            box-shadow: 0 0 8px rgba(156, 39, 176, 0.4);
        }
        
        .example-btns {
            display: flex;
            gap: 8px;
            margin-top: 10px;
            flex-wrap: wrap;
        }
        
        .example-btn {
            background: #2a3f5f;
            color: #e0e0e0;
            border: 1px solid #4fc3f7;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.75rem;
            transition: all 0.2s;
        }
        
        .example-btn:hover {
            background: #3a5f8f;
        }
        
        .analyze-btn {
            width: 100%;
            background: linear-gradient(135deg, #4fc3f7, #9c27b0);
            color: white;
            border: none;
            padding: 14px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            margin-top: 15px;
            transition: all 0.3s;
        }
        
        .analyze-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(156, 39, 176, 0.5);
        }
        
        .metrics {
            margin-top: 30px;
        }
        
        .metric-card {
            background: #0a0e27;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            border: 1px solid #2a3f5f;
        }
        
        .metric-name {
            font-size: 0.75rem;
            color: #90a4ae;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 8px;
        }
        
        .metric-value {
            font-size: 2rem;
            font-weight: bold;
            background: linear-gradient(135deg, #4fc3f7, #9c27b0);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 8px;
        }
        
        .metric-bar {
            height: 6px;
            background: #1a1f3a;
            border-radius: 3px;
            overflow: hidden;
            margin-bottom: 10px;
        }
        
        .metric-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #4fc3f7, #9c27b0);
            transition: width 0.5s ease;
        }
        
        .metric-desc {
            font-size: 0.8rem;
            color: #b0bec5;
            line-height: 1.4;
        }
        
        /* CENTER PANEL - 3D Attractor */
        .center-panel {
            background: #0f1228;
            position: relative;
            display: flex;
            flex-direction: column;
        }
        
        #cubeCanvas {
            flex: 1;
            cursor: grab;
        }
        
        #cubeCanvas:active {
            cursor: grabbing;
        }
        
        .cube-controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(26, 31, 58, 0.95);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #2a3f5f;
            backdrop-filter: blur(10px);
            max-width: 300px;
            transition: all 0.3s ease;
        }
        
        .cube-controls.collapsed {
            padding: 8px;
        }
        
        .cube-controls.collapsed .control-content {
            display: none;
        }
        
        .controls-toggle {
            background: linear-gradient(135deg, #4fc3f7, #9c27b0);
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.8rem;
            font-weight: 600;
            width: 100%;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            transition: all 0.2s;
        }
        
        .controls-toggle:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(79, 195, 247, 0.4);
        }
        
        .controls-toggle .toggle-icon {
            transition: transform 0.3s ease;
        }
        
        .cube-controls.collapsed .toggle-icon {
            transform: rotate(180deg);
        }
        
        .cube-controls h3 {
            font-size: 0.9rem;
            color: #4fc3f7;
            margin-bottom: 12px;
        }
        
        .control-group {
            margin-bottom: 12px;
        }
        
        .control-group label {
            font-size: 0.8rem;
            color: #90a4ae;
            display: block;
            margin-bottom: 6px;
        }
        
        .control-btn {
            width: 100%;
            background: #2a3f5f;
            color: #e0e0e0;
            border: 1px solid #4fc3f7;
            padding: 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8rem;
            margin-bottom: 6px;
            transition: all 0.2s;
        }
        
        .control-btn:hover {
            background: #3a5f8f;
        }
        
        .slider-group {
            margin-bottom: 10px;
        }
        
        .slider-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
            font-size: 0.75rem;
            color: #90a4ae;
        }
        
        input[type="range"] {
            width: 100%;
            height: 4px;
            background: #1a1f3a;
            border-radius: 2px;
            outline: none;
            -webkit-appearance: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 14px;
            height: 14px;
            background: linear-gradient(135deg, #4fc3f7, #9c27b0);
            cursor: pointer;
            border-radius: 50%;
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 14px;
            height: 14px;
            background: linear-gradient(135deg, #4fc3f7, #9c27b0);
            cursor: pointer;
            border-radius: 50%;
            border: none;
        }
        
        .state-info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(26, 31, 58, 0.95);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #4fc3f7;
            backdrop-filter: blur(10px);
            min-width: 250px;
            max-width: 90%;
            display: none;
            transition: all 0.3s ease;
        }
        
        .state-info.active {
            display: block;
        }
        
        .state-info-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding-bottom: 8px;
            border-bottom: 1px solid #2a3f5f;
        }
        
        .state-info-title {
            color: #4fc3f7;
            font-size: 0.85rem;
            font-weight: 600;
        }
        
        .state-info-close {
            background: transparent;
            border: none;
            color: #90a4ae;
            cursor: pointer;
            font-size: 1.2rem;
            padding: 0;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            transition: all 0.2s;
        }
        
        .state-info-close:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #4fc3f7;
        }
        
        .fab-container {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: none;
            flex-direction: column;
            gap: 10px;
            z-index: 100;
        }
        
        .fab {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: linear-gradient(135deg, #4fc3f7, #9c27b0);
            border: none;
            color: white;
            font-size: 1.2rem;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(79, 195, 247, 0.4);
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .fab:active {
            transform: scale(0.95);
            box-shadow: 0 2px 8px rgba(79, 195, 247, 0.3);
        }
        
        @media (max-width: 768px) {
            .fab-container {
                display: flex;
            }
        }
        
        .state-info-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 6px;
            font-size: 0.85rem;
        }
        
        .state-info-label {
            color: #90a4ae;
        }
        
        .state-info-value {
            color: #4fc3f7;
            font-family: 'Courier New', monospace;
            font-weight: bold;
        }
        
        /* RIGHT PANEL */
        .right-panel {
            background: linear-gradient(180deg, #1a1f3a 0%, #0f1228 100%);
            padding: 25px;
            overflow-y: auto;
            border-left: 1px solid #2a3f5f;
        }
        
        .panel-title {
            color: #4fc3f7;
            font-size: 1.1rem;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid #2a3f5f;
        }
        
        .attractor-stats {
            background: #0a0e27;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #2a3f5f;
            margin-bottom: 20px;
        }
        
        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 0.85rem;
        }
        
        .stat-label {
            color: #90a4ae;
        }
        
        .stat-value {
            color: #4fc3f7;
            font-weight: bold;
        }
        
        .grid-8x8 {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 2px;
            background: #0a0e27;
            padding: 2px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        
        .grid-cell {
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.65rem;
            font-weight: 600;
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }
        
        .grid-cell:hover {
            transform: scale(1.15);
            z-index: 10;
            box-shadow: 0 4px 12px rgba(79, 195, 247, 0.6);
        }
        
        .grid-cell.in-attractor {
            border: 2px solid rgba(79, 195, 247, 0.8);
            box-shadow: 0 0 8px rgba(79, 195, 247, 0.3);
        }
        
        .grid-info {
            background: #0a0e27;
            border: 1px solid #2a3f5f;
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 15px;
            display: none;
        }
        
        .grid-info.active {
            display: block;
        }
        
        .top-states {
            background: #0a0e27;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #2a3f5f;
        }
        
        .state-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            margin-bottom: 6px;
            background: #1a1f3a;
            border-radius: 4px;
            font-size: 0.8rem;
        }
        
        .state-index {
            color: #4fc3f7;
            font-weight: bold;
            font-family: 'Courier New', monospace;
        }
        
        .state-freq {
            color: #9c27b0;
        }
        
        .color-legend {
            background: #0a0e27;
            padding: 12px;
            border-radius: 8px;
            border: 1px solid #2a3f5f;
            margin-bottom: 15px;
        }
        
        .legend-title {
            font-size: 0.75rem;
            color: #90a4ae;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .legend-gradient {
            height: 20px;
            background: linear-gradient(90deg, 
                rgb(79, 0, 157),           /* Low frequency */
                rgb(79, 97, 202),
                rgb(79, 195, 247),         /* Medium frequency */
                rgb(118, 195, 219),
                rgb(156, 195, 157)         /* High frequency */
            );
            border-radius: 4px;
            margin-bottom: 6px;
        }
        
        .legend-labels {
            display: flex;
            justify-content: space-between;
            font-size: 0.7rem;
            color: #b0bec5;
            margin-bottom: 6px;
        }
        
        .legend-note {
            font-size: 0.65rem;
            color: #78909c;
            font-style: italic;
            text-align: center;
        }
        
        @media (max-width: 1400px) {
            .app-container {
                grid-template-columns: 280px 1fr 300px;
            }
        }
        
        @media (max-width: 1024px) {
            .app-container {
                grid-template-columns: 1fr;
                grid-template-rows: auto 60vh auto;
                height: auto;
                min-height: 100vh;
            }
            
            .left-panel, .right-panel {
                max-height: none;
                overflow-y: visible;
            }
            
            .center-panel {
                min-height: 60vh;
                position: relative;
            }
            
            .cube-controls {
                max-width: calc(100% - 40px);
            }
        }
        
        /* iPhone and mobile optimizations */
        @media (max-width: 768px) {
            body {
                overflow-y: auto;
                overflow-x: hidden;
            }
            
            .app-container {
                grid-template-columns: 1fr;
                grid-template-rows: auto minmax(400px, 50vh) auto;
                height: auto;
                min-height: 100vh;
            }
            
            .left-panel {
                padding: 15px;
                border-right: none;
                border-bottom: 1px solid #2a3f5f;
            }
            
            .right-panel {
                padding: 15px;
                border-left: none;
                border-top: 1px solid #2a3f5f;
            }
            
            .logo h1 {
                font-size: 1.3rem;
            }
            
            .logo p {
                font-size: 0.7rem;
            }
            
            textarea {
                min-height: 80px;
                font-size: 0.8rem;
            }
            
            .example-btns {
                gap: 6px;
            }
            
            .example-btn {
                padding: 5px 10px;
                font-size: 0.7rem;
                flex: 1;
                min-width: 70px;
            }
            
            .analyze-btn {
                padding: 12px;
                font-size: 0.9rem;
            }
            
            .metric-card {
                padding: 12px;
                margin-bottom: 12px;
            }
            
            .metric-name {
                font-size: 0.7rem;
            }
            
            .metric-value {
                font-size: 1.6rem;
            }
            
            .metric-desc {
                font-size: 0.75rem;
            }
            
            .center-panel {
                position: relative;
                min-height: 400px;
                height: 50vh;
            }
            
            #cubeCanvas {
                touch-action: none;
            }
            
            .cube-controls {
                top: 10px;
                left: 10px;
                right: 10px;
                padding: 10px;
                max-width: calc(100% - 20px);
                font-size: 0.85rem;
            }
            
            .cube-controls.collapsed {
                padding: 8px;
                max-width: 180px;
            }
            
            .controls-toggle {
                font-size: 0.75rem;
                padding: 6px 10px;
                margin-bottom: 8px;
            }
            
            .cube-controls h3 {
                font-size: 0.85rem;
                margin-bottom: 8px;
            }
            
            .control-btn {
                padding: 6px;
                font-size: 0.75rem;
                margin-bottom: 4px;
            }
            
            .slider-group {
                margin-bottom: 8px;
            }
            
            .slider-label {
                font-size: 0.7rem;
            }
            
            input[type="range"] {
                height: 6px;
            }
            
            input[type="range"]::-webkit-slider-thumb {
                width: 18px;
                height: 18px;
            }
            
            input[type="range"]::-moz-range-thumb {
                width: 18px;
                height: 18px;
            }
            
            .state-info {
                bottom: 10px;
                left: 10px;
                right: 10px;
                min-width: auto;
                max-width: calc(100% - 20px);
                padding: 10px;
            }
            
            .state-info-header {
                margin-bottom: 8px;
                padding-bottom: 6px;
            }
            
            .state-info-title {
                font-size: 0.8rem;
            }
            
            .state-info-row {
                font-size: 0.75rem;
                margin-bottom: 4px;
            }
            
            .panel-title {
                font-size: 1rem;
                margin-bottom: 15px;
            }
            
            .attractor-stats {
                padding: 12px;
                margin-bottom: 15px;
            }
            
            .stat-row {
                font-size: 0.8rem;
                margin-bottom: 6px;
            }
            
            .grid-8x8 {
                gap: 1px;
                padding: 1px;
                margin-bottom: 15px;
            }
            
            .grid-cell {
                font-size: 0.6rem;
            }
            
            .top-states {
                padding: 12px;
            }
            
            .state-item {
                padding: 6px;
                margin-bottom: 4px;
                font-size: 0.75rem;
            }
        }
        
        /* iPhone SE and smaller */
        @media (max-width: 375px) {
            .logo h1 {
                font-size: 1.1rem;
            }
            
            .metric-value {
                font-size: 1.4rem;
            }
            
            .cube-controls {
                padding: 8px;
                font-size: 0.8rem;
            }
            
            .control-btn {
                padding: 5px;
                font-size: 0.7rem;
            }
            
            .grid-cell {
                font-size: 0.55rem;
            }
            
            .state-item {
                font-size: 0.7rem;
            }
        }
        
        /* Landscape mobile */
        @media (max-width: 900px) and (orientation: landscape) {
            .app-container {
                grid-template-columns: 280px 1fr 280px;
                grid-template-rows: 1fr;
                height: 100vh;
            }
            
            .left-panel, .right-panel {
                overflow-y: auto;
                max-height: 100vh;
            }
            
            .center-panel {
                min-height: auto;
                height: 100vh;
            }
            
            .cube-controls {
                max-width: 250px;
            }
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- LEFT PANEL -->
        <div class="left-panel">
            <div class="logo">
                <h1>SUBIT 3D</h1>
                <p>Attractor Visualization Engine</p>
            </div>
            
            <div class="input-section">
                <label for="inputFlow">Input Flow</label>
                <textarea id="inputFlow" placeholder="Enter text or binary string...&#10;&#10;Try: 'The quick brown fox'&#10;Or analyze mathematical constants like œÄ"></textarea>
                
                <div class="example-btns">
                    <button class="example-btn" onclick="loadExample('text')">üìù Text</button>
                    <button class="example-btn" onclick="loadExample('binary')">0/1</button>
                    <button class="example-btn" onclick="loadExample('pi')">œÄ Sim</button>
                </div>
                
                <button class="analyze-btn" onclick="analyzeFlow()">üîç Analyze Flow</button>
            </div>
            
            <div class="metrics" id="metricsPanel" style="display: none;">
                <div class="metric-card">
                    <div class="metric-name">Entropy (E)</div>
                    <div class="metric-value" id="metricE">0.000</div>
                    <div class="metric-bar">
                        <div class="metric-bar-fill" id="barE"></div>
                    </div>
                    <div class="metric-desc" id="descE"></div>
                </div>
                
                <div class="metric-card">
                    <div class="metric-name">Anisotropy (A)</div>
                    <div class="metric-value" id="metricA">0.000</div>
                    <div class="metric-bar">
                        <div class="metric-bar-fill" id="barA"></div>
                    </div>
                    <div class="metric-desc" id="descA"></div>
                </div>
                
                <div class="metric-card">
                    <div class="metric-name">Tension (T)</div>
                    <div class="metric-value" id="metricT">0.000</div>
                    <div class="metric-bar">
                        <div class="metric-bar-fill" id="barT"></div>
                    </div>
                    <div class="metric-desc" id="descT"></div>
                </div>
            </div>
        </div>
        
        <!-- CENTER PANEL - 3D Attractor -->
        <div class="center-panel">
            <canvas id="cubeCanvas"></canvas>
            
            <div class="cube-controls" id="cubeControls">
                <button class="controls-toggle" onclick="toggleControls()">
                    <span>Controls</span>
                    <span class="toggle-icon">‚ñº</span>
                </button>
                
                <div class="control-content">
                    <div class="control-group">
                        <button class="control-btn" onclick="resetCamera()">‚Ü∫ Reset Camera</button>
                        <button class="control-btn" onclick="toggleEdges()">‚ü∑ Toggle Transitions</button>
                        <button class="control-btn" onclick="toggleInactive()">‚óØ Show All States</button>
                    </div>
                    
                    <div class="slider-group">
                        <div class="slider-label">
                            <span>Node Size</span>
                            <span id="nodeSizeValue">1.0</span>
                        </div>
                        <input type="range" id="nodeSizeSlider" min="0.3" max="2.0" step="0.1" value="1.0" oninput="updateNodeSize(this.value)">
                    </div>
                    
                    <div class="slider-group">
                        <div class="slider-label">
                            <span>Edge Opacity</span>
                            <span id="edgeOpacityValue">0.3</span>
                        </div>
                        <input type="range" id="edgeOpacitySlider" min="0.0" max="1.0" step="0.05" value="0.3" oninput="updateEdgeOpacity(this.value)">
                    </div>
                    
                    <div class="slider-group">
                        <div class="slider-label">
                            <span>Min Transition</span>
                            <span id="minTransValue">0.01</span>
                        </div>
                        <input type="range" id="minTransSlider" min="0.0" max="0.1" step="0.005" value="0.01" oninput="updateMinTransition(this.value)">
                    </div>
                </div>
            </div>
            
            <div class="state-info" id="stateInfo">
                <div class="state-info-header">
                    <span class="state-info-title">State Details</span>
                    <button class="state-info-close" onclick="closeStateInfo()">‚úï</button>
                </div>
                <div class="state-info-row">
                    <span class="state-info-label">State:</span>
                    <span class="state-info-value" id="infoState">‚Äî</span>
                </div>
                <div class="state-info-row">
                    <span class="state-info-label">Binary:</span>
                    <span class="state-info-value" id="infoBinary">‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî</span>
                </div>
                <div class="state-info-row">
                    <span class="state-info-label">Position:</span>
                    <span class="state-info-value" id="infoXYZ">‚Äî</span>
                </div>
                <div class="state-info-row">
                    <span class="state-info-label">Frequency:</span>
                    <span class="state-info-value" id="infoFreq">‚Äî</span>
                </div>
                <div class="state-info-row">
                    <span class="state-info-label">Out-degree:</span>
                    <span class="state-info-value" id="infoOutDeg">‚Äî</span>
                </div>
            </div>
            
            <div class="fab-container">
                <button class="fab" onclick="resetCamera()" title="Reset Camera">‚Ü∫</button>
                <button class="fab" onclick="toggleControls()" title="Toggle Controls">‚öô</button>
            </div>
        </div>
        
        <!-- RIGHT PANEL -->
        <div class="right-panel">
            <h2 class="panel-title">Attractor Structure</h2>
            
            <div class="attractor-stats">
                <div class="stat-row">
                    <span class="stat-label">Attractor Size |A|:</span>
                    <span class="stat-value" id="statAttractorSize">‚Äî</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Coverage:</span>
                    <span class="stat-value" id="statCoverage">‚Äî</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Total Windows:</span>
                    <span class="stat-value" id="statWindows">‚Äî</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Transitions:</span>
                    <span class="stat-value" id="statTransitions">‚Äî</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Max Frequency:</span>
                    <span class="stat-value" id="statMaxFreq">‚Äî</span>
                </div>
            </div>
            
            <h3 class="panel-title" style="margin-top: 20px;">8√ó8 State Grid</h3>
            <div class="grid-8x8" id="grid8x8"></div>
            
            <div class="grid-info" id="gridInfo">
                <div class="state-info-row">
                    <span class="state-info-label">State:</span>
                    <span class="state-info-value" id="gridInfoState">‚Äî</span>
                </div>
                <div class="state-info-row">
                    <span class="state-info-label">Position:</span>
                    <span class="state-info-value" id="gridInfoPos">‚Äî</span>
                </div>
                <div class="state-info-row">
                    <span class="state-info-label">Frequency:</span>
                    <span class="state-info-value" id="gridInfoProb">‚Äî</span>
                </div>
            </div>
            
            <div class="color-legend">
                <div class="legend-title">Frequency Scale</div>
                <div class="legend-gradient"></div>
                <div class="legend-labels">
                    <span>Low</span>
                    <span>High</span>
                </div>
                <div class="legend-note">Color intensity shows visit frequency</div>
            </div>
            
            <h3 class="panel-title" style="margin-top: 20px;">Top Active States</h3>
            <div class="top-states" id="topStates"></div>
        </div>
    </div>
    
    <!-- Three.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    
    <script>
        // ========================================
        // GLOBAL STATE
        // ========================================
        
        let scene, camera, renderer, controls;
        let nodes = [];
        let edges = [];
        let currentAttractor = null; // {A, F, P, coords}
        let selectedNode = null;
        let showEdges = true;
        let showInactive = false;
        let nodeSizeScale = 1.0;
        let edgeOpacityScale = 0.3;
        let minTransition = 0.01;
        
        // ========================================
        // 3D INITIALIZATION
        // ========================================
        
        function init3D() {
            const canvas = document.getElementById('cubeCanvas');
            const width = canvas.clientWidth;
            const height = canvas.clientHeight;
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0f1228);
            
            camera = new THREE.PerspectiveCamera(60, width / height, 0.1, 1000);
            camera.position.set(8, 8, 8);
            camera.lookAt(1.5, 1.5, 1.5);
            
            renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: false });
            renderer.setSize(width, height);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Limit for performance on mobile
            
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.target.set(1.5, 1.5, 1.5);
            
            // Touch-friendly settings
            controls.rotateSpeed = 0.5;
            controls.zoomSpeed = 0.8;
            controls.panSpeed = 0.5;
            controls.touches = {
                ONE: THREE.TOUCH.ROTATE,
                TWO: THREE.TOUCH.DOLLY_PAN
            };
            
            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);
            
            const pointLight1 = new THREE.PointLight(0x4fc3f7, 0.8, 100);
            pointLight1.position.set(10, 10, 10);
            scene.add(pointLight1);
            
            const pointLight2 = new THREE.PointLight(0x9c27b0, 0.4, 100);
            pointLight2.position.set(-10, -10, -10);
            scene.add(pointLight2);
            
            // Grid
            const gridHelper = new THREE.GridHelper(6, 6, 0x2a3f5f, 0x1a1f3a);
            gridHelper.position.set(1.5, -0.5, 1.5);
            scene.add(gridHelper);
            
            // Axes
            const axesHelper = new THREE.AxesHelper(5);
            scene.add(axesHelper);
            
            window.addEventListener('resize', onWindowResize);
            canvas.addEventListener('click', onCanvasClick);
            canvas.addEventListener('touchend', onCanvasClick);
            
            // Touch event handling for iPhone
            canvas.addEventListener('touchstart', function(e) {
                if (e.touches.length === 1) {
                    e.preventDefault();
                }
            }, { passive: false });
            
            animate();
        }
        
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        
        function onWindowResize() {
            const canvas = document.getElementById('cubeCanvas');
            camera.aspect = canvas.clientWidth / canvas.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(canvas.clientWidth, canvas.clientHeight);
        }
        
        // ========================================
        // SUBIT ANALYSIS
        // ========================================
        
        function flowToBits(flow) {
            if (/^[01\s]+$/.test(flow.trim())) {
                return flow.replace(/\s/g, '');
            }
            const encoder = new TextEncoder();
            const bytes = encoder.encode(flow);
            let bits = '';
            for (const byte of bytes) {
                bits += byte.toString(2).padStart(8, '0');
            }
            return bits;
        }
        
        function extractAttractor(bits) {
            const trajectory = [];
            
            // Build trajectory
            for (let i = 0; i <= bits.length - 6; i++) {
                const window = bits.substr(i, 6);
                const state = parseInt(window, 2);
                trajectory.push(state);
            }
            
            // Invariant set A
            const A = [...new Set(trajectory)].sort((a, b) => a - b);
            
            // Frequencies F
            const counts = new Array(64).fill(0);
            for (const state of trajectory) {
                counts[state]++;
            }
            const total = trajectory.length;
            const F = counts.map(c => c / total);
            
            // Transition matrix P
            const M = Array(64).fill(null).map(() => Array(64).fill(0));
            for (let i = 0; i < trajectory.length - 1; i++) {
                const a = trajectory[i];
                const b = trajectory[i + 1];
                M[a][b]++;
            }
            
            const P = Array(64).fill(null).map(() => Array(64).fill(0));
            for (let a = 0; a < 64; a++) {
                const rowSum = M[a].reduce((sum, val) => sum + val, 0);
                if (rowSum > 0) {
                    for (let b = 0; b < 64; b++) {
                        P[a][b] = M[a][b] / rowSum;
                    }
                }
            }
            
            // Coordinates (4√ó4√ó4 cube)
            const coords = {};
            for (let k = 0; k < 64; k++) {
                coords[k] = {
                    X: (k >> 4) & 3,
                    Y: (k >> 2) & 3,
                    Z: k & 3
                };
            }
            
            return { A, F, P, coords, trajectory };
        }
        
        function stateToBinary(k) {
            return k.toString(2).padStart(6, '0');
        }
        
        // ========================================
        // ATTRACTOR VISUALIZATION
        // ========================================
        
        function getColorForFreq(freq, maxFreq, isActive) {
            if (!isActive && !showInactive) return new THREE.Color(0x1a1f3a);
            
            if (!isActive) {
                return new THREE.Color(0x2a3f5f);
            }
            
            if (freq === 0) return new THREE.Color(0x1a1f3a);
            
            // Normalize frequency to 0-1 range
            const intensity = maxFreq > 0 ? freq / maxFreq : 0;
            
            // Color gradient: dark blue (low) ‚Üí bright cyan/purple (high)
            const r = Math.floor(79 + intensity * 77);   // 79 ‚Üí 156
            const g = Math.floor(195 * intensity);        // 0 ‚Üí 195  
            const b = Math.floor(247 - intensity * 90);   // 247 ‚Üí 157
            
            return new THREE.Color(`rgb(${r}, ${g}, ${b})`);
        }
        
        function createNode(k, freq, maxFreq, coords, isActive) {
            const { X, Y, Z } = coords;
            
            const baseSize = 0.25;
            let size;
            
            if (isActive) {
                // Size proportional to frequency for active nodes
                const freqRatio = maxFreq > 0 ? freq / maxFreq : 0;
                size = baseSize * nodeSizeScale * (0.5 + 1.5 * freqRatio);
            } else {
                // Small size for inactive nodes
                size = baseSize * nodeSizeScale * 0.3;
            }
            
            const geometry = new THREE.SphereGeometry(size, 16, 16);
            const color = getColorForFreq(freq, maxFreq, isActive);
            
            const material = new THREE.MeshPhongMaterial({
                color: color,
                emissive: isActive ? color : new THREE.Color(0x000000),
                emissiveIntensity: isActive && freq > 0 ? 0.4 : 0,
                shininess: 60,
                transparent: true,
                opacity: isActive ? (0.7 + 0.3 * (freq / maxFreq)) : 0.3
            });
            
            const sphere = new THREE.Mesh(geometry, material);
            sphere.position.set(X, Y, Z);
            sphere.userData = { state: k, freq, X, Y, Z, isActive };
            
            return sphere;
        }
        
        function createEdge(fromNode, toNode, prob) {
            const from = fromNode.position;
            const to = toNode.position;
            
            const points = [from, to];
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            
            const opacity = edgeOpacityScale * Math.pow(prob, 0.5);
            const thickness = 1 + 3 * prob;
            
            const material = new THREE.LineBasicMaterial({
                color: 0x4fc3f7,
                transparent: true,
                opacity: opacity,
                linewidth: thickness
            });
            
            const line = new THREE.Line(geometry, material);
            line.userData = { prob };
            
            return line;
        }
        
        function renderAttractor(attractor) {
            // Clear old visualization
            nodes.forEach(node => scene.remove(node));
            edges.forEach(edge => scene.remove(edge));
            nodes = [];
            edges = [];
            
            const { A, F, P, coords } = attractor;
            const maxFreq = Math.max(...F);
            
            // Create nodes
            for (let k = 0; k < 64; k++) {
                const isActive = A.includes(k);
                const node = createNode(k, F[k], maxFreq, coords[k], isActive);
                
                if (isActive || showInactive) {
                    scene.add(node);
                    nodes.push(node);
                }
            }
            
            // Create edges (only between active states)
            if (showEdges) {
                for (const a of A) {
                    for (const b of A) {
                        if (P[a][b] > minTransition) {
                            const fromNode = nodes.find(n => n.userData.state === a);
                            const toNode = nodes.find(n => n.userData.state === b);
                            
                            if (fromNode && toNode) {
                                const edge = createEdge(fromNode, toNode, P[a][b]);
                                scene.add(edge);
                                edges.push(edge);
                            }
                        }
                    }
                }
            }
        }
        
        function onCanvasClick(event) {
            const canvas = document.getElementById('cubeCanvas');
            const rect = canvas.getBoundingClientRect();
            
            // Handle both click and touch events
            let clientX, clientY;
            
            if (event.type === 'touchend' && event.changedTouches) {
                clientX = event.changedTouches[0].clientX;
                clientY = event.changedTouches[0].clientY;
            } else if (event.touches && event.touches[0]) {
                clientX = event.touches[0].clientX;
                clientY = event.touches[0].clientY;
            } else {
                clientX = event.clientX;
                clientY = event.clientY;
            }
            
            if (!clientX || !clientY) return;
            
            const mouse = new THREE.Vector2(
                ((clientX - rect.left) / rect.width) * 2 - 1,
                -((clientY - rect.top) / rect.height) * 2 + 1
            );
            
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);
            
            // Increase threshold for touch targets
            raycaster.params.Points.threshold = 0.3;
            
            const intersects = raycaster.intersectObjects(nodes);
            
            if (intersects.length > 0) {
                event.preventDefault();
                selectNode(intersects[0].object);
            }
        }
        
        function selectNode(node) {
            if (selectedNode) {
                selectedNode.scale.set(1, 1, 1);
            }
            
            selectedNode = node;
            node.scale.set(1.4, 1.4, 1.4);
            
            const { state, freq, X, Y, Z } = node.userData;
            
            // Count outgoing transitions
            const outDegree = currentAttractor.P[state].filter(p => p > minTransition).length;
            
            document.getElementById('infoState').textContent = state;
            document.getElementById('infoBinary').textContent = stateToBinary(state);
            document.getElementById('infoXYZ').textContent = `(${X}, ${Y}, ${Z})`;
            document.getElementById('infoFreq').textContent = freq.toFixed(6);
            document.getElementById('infoOutDeg').textContent = outDegree;
            document.getElementById('stateInfo').classList.add('active');
        }
        
        // ========================================
        // CONTROLS
        // ========================================
        
        function toggleControls() {
            const controls = document.getElementById('cubeControls');
            controls.classList.toggle('collapsed');
        }
        
        function closeStateInfo() {
            document.getElementById('stateInfo').classList.remove('active');
            if (selectedNode) {
                selectedNode.scale.set(1, 1, 1);
                selectedNode = null;
            }
        }
        
        function resetCamera() {
            camera.position.set(8, 8, 8);
            controls.target.set(1.5, 1.5, 1.5);
            controls.update();
        }
        
        function toggleEdges() {
            showEdges = !showEdges;
            if (currentAttractor) {
                renderAttractor(currentAttractor);
            }
        }
        
        function toggleInactive() {
            showInactive = !showInactive;
            if (currentAttractor) {
                renderAttractor(currentAttractor);
            }
        }
        
        function updateNodeSize(value) {
            nodeSizeScale = parseFloat(value);
            document.getElementById('nodeSizeValue').textContent = value;
            if (currentAttractor) {
                renderAttractor(currentAttractor);
            }
        }
        
        function updateEdgeOpacity(value) {
            edgeOpacityScale = parseFloat(value);
            document.getElementById('edgeOpacityValue').textContent = value;
            if (currentAttractor) {
                renderAttractor(currentAttractor);
            }
        }
        
        function updateMinTransition(value) {
            minTransition = parseFloat(value);
            document.getElementById('minTransValue').textContent = value;
            if (currentAttractor) {
                renderAttractor(currentAttractor);
            }
        }
        
        // ========================================
        // METRICS
        // ========================================
        
        function calculateEntropy(probs) {
            let H = 0;
            for (const p of probs) {
                if (p > 0) {
                    H -= p * Math.log2(p);
                }
            }
            return H / 6.0;
        }
        
        function calculateAnisotropy(probs) {
            let x_mean = 0, y_mean = 0;
            
            for (let k = 0; k < 64; k++) {
                const row = Math.floor(k / 8);
                const col = k % 8;
                x_mean += probs[k] * row;
                y_mean += probs[k] * col;
            }
            
            let cov_xx = 0, cov_yy = 0, cov_xy = 0;
            
            for (let k = 0; k < 64; k++) {
                const row = Math.floor(k / 8);
                const col = k % 8;
                const dx = row - x_mean;
                const dy = col - y_mean;
                
                cov_xx += probs[k] * dx * dx;
                cov_yy += probs[k] * dy * dy;
                cov_xy += probs[k] * dx * dy;
            }
            
            const tr = cov_xx + cov_yy;
            const det = cov_xx * cov_yy - cov_xy * cov_xy;
            const disc = Math.max(tr * tr - 4 * det, 0);
            
            const lambda1 = (tr + Math.sqrt(disc)) / 2;
            const lambda2 = (tr - Math.sqrt(disc)) / 2;
            
            return lambda1 > 0 ? 1 - (lambda2 / lambda1) : 0;
        }
        
        function calculateTension(probs) {
            const center_x = 3.5, center_y = 3.5;
            const distances = [];
            
            for (let k = 0; k < 64; k++) {
                const row = Math.floor(k / 8);
                const col = k % 8;
                const d = Math.sqrt((row - center_x) ** 2 + (col - center_y) ** 2);
                distances.push(d);
            }
            
            const max_d = Math.max(...distances);
            const n_rings = 5;
            const ring_size = max_d / n_rings;
            
            const ring_probs = new Array(n_rings).fill(0);
            const ring_counts = new Array(n_rings).fill(0);
            
            for (let k = 0; k < 64; k++) {
                const ring = Math.min(Math.floor(distances[k] / ring_size), n_rings - 1);
                ring_probs[ring] += probs[k];
                ring_counts[ring]++;
            }
            
            const mean_ring_probs = ring_probs.map((sum, i) => 
                ring_counts[i] > 0 ? sum / ring_counts[i] : 0
            );
            
            const mean_all = probs.reduce((a, b) => a + b, 0) / 64;
            const std_all = Math.sqrt(
                probs.reduce((sum, p) => sum + (p - mean_all) ** 2, 0) / 64
            );
            
            const mean_rings = mean_ring_probs.reduce((a, b) => a + b, 0) / n_rings;
            const std_rings = Math.sqrt(
                mean_ring_probs.reduce((sum, p) => sum + (p - mean_rings) ** 2, 0) / n_rings
            );
            
            return std_all > 0 ? std_rings / std_all : 0;
        }
        
        function displayMetrics(E, A, T) {
            document.getElementById('metricE').textContent = E.toFixed(3);
            document.getElementById('metricA').textContent = A.toFixed(3);
            document.getElementById('metricT').textContent = T.toFixed(3);
            
            document.getElementById('barE').style.width = (E * 100) + '%';
            document.getElementById('barA').style.width = (A * 100) + '%';
            document.getElementById('barT').style.width = (T * 100) + '%';
            
            document.getElementById('descE').textContent = interpretE(E);
            document.getElementById('descA').textContent = interpretA(A);
            document.getElementById('descT').textContent = interpretT(T);
            
            document.getElementById('metricsPanel').style.display = 'block';
        }
        
        function interpretE(E) {
            if (E < 0.3) return 'Low: Highly predictable';
            if (E < 0.7) return 'Moderate: Balanced structure';
            return 'High: Highly unpredictable';
        }
        
        function interpretA(A) {
            if (A < 0.3) return 'Low: Symmetric distribution';
            if (A < 0.7) return 'Moderate: Some directionality';
            return 'High: Strong directional bias';
        }
        
        function interpretT(T) {
            if (T < 0.3) return 'Low: Uniform distribution';
            if (T < 0.7) return 'Moderate: Some clustering';
            return 'High: Core-periphery structure';
        }
        
        // ========================================
        // UI UPDATES
        // ========================================
        
        function renderGrid(F, A) {
            const container = document.getElementById('grid8x8');
            container.innerHTML = '';
            
            const maxF = Math.max(...F);
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const k = row * 8 + col;
                    const cell = document.createElement('div');
                    cell.className = 'grid-cell';
                    
                    const isActive = A.includes(k);
                    
                    if (isActive) {
                        cell.classList.add('in-attractor');
                    }
                    
                    // Get color based on frequency
                    const freq = F[k];
                    const color = getColorForFreq(freq, maxF, isActive);
                    cell.style.background = `#${color.getHexString()}`;
                    
                    // Show state number
                    cell.textContent = k;
                    
                    // Adjust text color for readability
                    if (freq > maxF * 0.5) {
                        cell.style.color = '#0a0e27';
                    } else {
                        cell.style.color = '#e0e0e0';
                    }
                    
                    cell.onclick = () => showGridInfo(k, freq, row, col);
                    
                    container.appendChild(cell);
                }
            }
        }
        
        function showGridInfo(k, freq, row, col) {
            const gridInfo = document.getElementById('gridInfo');
            if (!gridInfo) return;
            
            const stateEl = gridInfo.querySelector('#gridInfoState');
            const posEl = gridInfo.querySelector('#gridInfoPos');
            const probEl = gridInfo.querySelector('#gridInfoProb');
            
            if (stateEl) stateEl.textContent = `${k} (${stateToBinary(k)})`;
            if (posEl) posEl.textContent = `(${row}, ${col})`;
            if (probEl) probEl.textContent = `${freq.toFixed(6)} (${(freq * 100).toFixed(2)}%)`;
            
            gridInfo.classList.add('active');
        }
        
        function displayTopStates(F, A) {
            const container = document.getElementById('topStates');
            container.innerHTML = '';
            
            const sorted = A
                .map(k => ({ k, freq: F[k] }))
                .sort((a, b) => b.freq - a.freq)
                .slice(0, 10);
            
            sorted.forEach(({ k, freq }) => {
                const item = document.createElement('div');
                item.className = 'state-item';
                item.innerHTML = `
                    <span class="state-index">${k} (${stateToBinary(k)})</span>
                    <span class="state-freq">${(freq * 100).toFixed(2)}%</span>
                `;
                container.appendChild(item);
            });
        }
        
        function updateStats(attractor) {
            const { A, F, P, trajectory } = attractor;
            
            let transitionCount = 0;
            for (let a = 0; a < 64; a++) {
                for (let b = 0; b < 64; b++) {
                    if (P[a][b] > minTransition) transitionCount++;
                }
            }
            
            document.getElementById('statAttractorSize').textContent = `${A.length} / 64`;
            document.getElementById('statCoverage').textContent = `${((A.length / 64) * 100).toFixed(1)}%`;
            document.getElementById('statWindows').textContent = trajectory.length;
            document.getElementById('statTransitions').textContent = transitionCount;
            document.getElementById('statMaxFreq').textContent = Math.max(...F).toFixed(6);
        }
        
        // ========================================
        // EXAMPLES
        // ========================================
        
        function loadExample(type) {
            const input = document.getElementById('inputFlow');
            switch(type) {
                case 'text':
                    input.value = 'The quick brown fox jumps over the lazy dog. Information flows through semantic channels and creates stable attractors in state space.';
                    break;
                case 'binary':
                    input.value = '010110100111001010110011010001110101001110010101101001010111001010110100' +
                                  '101101001110010101100110100011101010011100101011010010101110010101101001';
                    break;
                case 'pi':
                    // Simulate œÄ-like pseudo-random binary
                    let piBits = '';
                    for (let i = 0; i < 500; i++) {
                        piBits += Math.random() > 0.5 ? '1' : '0';
                    }
                    input.value = piBits;
                    break;
            }
        }
        
        // ========================================
        // MAIN ANALYSIS
        // ========================================
        
        function analyzeFlow() {
            const input = document.getElementById('inputFlow').value.trim();
            
            if (!input) {
                alert('Please enter some data');
                return;
            }
            
            const bits = flowToBits(input);
            
            if (bits.length < 6) {
                alert('Input too short (need at least 6 bits)');
                return;
            }
            
            // Extract attractor
            currentAttractor = extractAttractor(bits);
            const { A, F, P } = currentAttractor;
            
            // Render 3D
            renderAttractor(currentAttractor);
            
            // Metrics
            const E = calculateEntropy(F);
            const AA = calculateAnisotropy(F);
            const T = calculateTension(F);
            
            displayMetrics(E, AA, T);
            
            // UI updates
            renderGrid(F, A);
            displayTopStates(F, A);
            updateStats(currentAttractor);
            
            // Auto-collapse controls on mobile
            if (window.innerWidth <= 768) {
                const controls = document.getElementById('cubeControls');
                controls.classList.add('collapsed');
            }
            
            console.log('Attractor analyzed:', {
                attractorSize: A.length,
                totalTransitions: P.flat().filter(p => p > 0).length,
                maxFreq: Math.max(...F)
            });
        }
        
        // ========================================
        // STARTUP
        // ========================================
        
        window.addEventListener('load', () => {
            init3D();
            console.log('SUBIT 3D Attractor Explorer initialized');
        });
    </script>
</body>
</html>
